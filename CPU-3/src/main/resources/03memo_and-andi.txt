行いたい命令：
①「0」番目のレジスタを指定し、そこに値「10」を代入する
②「1」番目のレジスタを指定し、そこに値「24」を代入する
③「2」番目のレジスタを指定し、そこに値「15」を代入する
④「3」番目のレジスタを指定し、「0」番目のレジスタと値「3」を比較した結果を保存する
→ここでの「andi」はビットごとのAND演算を指す、00001010(10)と00000011(3)のビットごとのAND演算は00000010(2)になる
⑤「4」番目のレジスタを指定し、「1」番目のレジスタと「2」番目のレジスタの値を比較した結果を保存する
→ここでも「and」はビットごとのAND演算を指す、00011000(24)と00001111(15)のビットごとのAND演算は00001000(8)になる
（Point: AND演算はビット列のマスクに使用することが多く、下位3ビットを取り出すマスクとして7(0000111)と比較する、などの手法が良く使われる）


命令のバイナリ表現：0,1だけで表現する
①00000000_00000000_00000000_00001010_000_00000_001_00010（I形式）
②00000000_00000000_00000000_00011000_001_00001_001_00010（I形式）
③00000000_00000000_00000000_00000011_010_00010_001_00010（I形式）
④00000000_00000000_00000000_00000011_000_00011_000_01000（I形式）
⑤0000000000_0000000000_00000_00010_00001_00100_000_00111（R形式）

命令の16進数表現：0-9, a-fで表現する、バイナリ表現を4桁ずつ区切る
①00_00_00_0a_00_22
②00_00_00_18_21_22
③00_00_00_0f_42_22
④00_00_00_03_03_08
⑤00_00_00_08_24_07

命令を入れる順番：リトルエンディアン
①00_00_00_0a_00_22 → bootrom.hexには22,00,0a,00,00,00の順番で入れる
②00_00_00_18_21_22 → bootrom.hexには22,21,18,00,00,00の順番で入れる
③00_00_00_0f_42_22 → bootrom.hexには22,42,0f,00,00,00の順番で入れる
④00_00_00_03_03_08 → bootrom.hexには08,03,03,00,00,00の順番で入れる
⑤00_00_00_08_24_07 → bootrom.hexには07,24,08,00,00,00の順番で入れる

Core.scalaの以下を修正
15行目
    loadMemoryFromFile(mem, "src/main/resources/03_and-andi.hex")
105行目
    io.out := regfile(4)

TopTest.scalaの以下を修正
11行目
      dut.clock.step(5)
12行目
      dut.io.out.expect(8.U)
